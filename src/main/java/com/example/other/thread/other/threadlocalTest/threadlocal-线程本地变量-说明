https://my.oschina.net/clopopo/blog/149368
http://www.cnblogs.com/alphablox/archive/2013/01/20/2869061.html

=================================ThreadLocal官方描述：
该类提供了线程局部 (thread-local) 变量。这些变量不同于它们的普通对应物，
因为访问某个变量（通过其 get 或 set 方法）的每个线程都有自己的局部变量，它独立于变量的初始化副本。
ThreadLocal 实例通常是类中的 private static 字段，它们希望将状态与某一个线程（例如，用户 ID 或事务 ID）相关联。

1、每个线程都有自己的局部变量，各个线程处理自己的本地变量值，线程之间互不影响。
	每个线程都有一个独立于其他线程的上下文来保存这个变量，一个线程的本地变量对其他线程是不可见的（有前提，后面解释）

2、独立于变量的初始化副本
    ThreadLocal可以给一个初始值，而每个线程都会获得这个初始化值的一个副本，这样才能保证不同的线程都有一份拷贝。

3、状态与某一个线程相关联
    ThreadLocal 不是用于解决共享变量的问题的，不是为了协调线程同步而存在，而是为了方便每个线程处理自己的状态而引入的一个机制，理解这点对正确使用ThreadLocal至关重要。

=================================什么时候用ThreadLocal？
一句话：不需要在不同的线程中共享变量

如果你定义了一个单实例的java bean，它有若干属性，但是有一个属性不是线程安全的，比如说HashMap。
并且碰巧你并不需要在不同的线程中共享这个属性，也就是说这个属性不存在跨线程的意义。
那么你不要sychronize这么复杂的东西，ThreadLocal将是你不错的选择。

==================================ThreadLocal不能解决什么问题？
ThreadLocal无法解决共享对象的更新问题
